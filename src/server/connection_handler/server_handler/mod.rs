use std::{
    collections::HashMap,
    sync::{atomic::AtomicBool, Arc},
};

use crate::server::{connection::Connection, database::DatabaseHandle};

use super::{
    ConnectionHandler, ConnectionHandlerCommands, ConnectionHandlerGetters,
    ConnectionHandlerStructure,
};

/// Asserts to ensure the commands the server sends are valid.
mod asserts;
/// Logic for the commands a server may send.
mod logic;
/// Responses generated by the commands.
mod responses;
/// Extra functions that help with the command's logic.
mod utils;

/// Unit tests for each command.
#[cfg(test)]
mod tests;

/// A Client Handler handles the connection with an already registered server.
pub struct ServerHandler<C: Connection> {
    stream: C,
    servername: String,
    database: DatabaseHandle<C>,
    online: Arc<AtomicBool>,
    hopcounts: HashMap<String, usize>,
}

impl<C: Connection> ConnectionHandler<C> for ServerHandler<C> {}

impl<C: Connection> ServerHandler<C> {
    /// Starts a [`ServerHandler`] with the received information.
    pub fn from_connection(
        stream: C,
        servername: String,
        database: DatabaseHandle<C>,
        online: Arc<AtomicBool>,
    ) -> std::io::Result<Self> {
        Ok(Self {
            stream,
            servername,
            database,
            online,
            hopcounts: HashMap::new(),
        })
    }
}

impl<C: Connection> ConnectionHandlerGetters<C> for ServerHandler<C> {
    fn online(&self) -> &Arc<AtomicBool> {
        &self.online
    }

    fn stream(&mut self) -> &mut C {
        &mut self.stream
    }

    fn database(&self) -> &DatabaseHandle<C> {
        &self.database
    }
}

impl<C: Connection> ConnectionHandlerStructure<C> for ServerHandler<C> {
    fn on_try_handle_error(&mut self) {
        eprintln!("Connection with [{}] ended unexpectedly", self.servername)
    }
    fn on_try_handle_success(&mut self) {
        eprintln!("Closing conection with [{}]", self.servername)
    }
}

impl<C: Connection> ConnectionHandlerCommands<C> for ServerHandler<C> {}
